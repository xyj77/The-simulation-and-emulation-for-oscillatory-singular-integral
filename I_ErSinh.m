function Er = I_ErSinh( fun , w , n , t , tag )
%示例Sinh(x)误差计算

%============================例二积分精确值=================================
% I=(1/2)*(exp((1+1i*w)*t)*(Ei((1+1i*w)*(1-t))-Ei((1+1i*w)*(-1-t))-1i*pi)...
%     -exp((-1+1i*w)*t)*(Ei((-1+1i*w)*(1-t))-Ei((-1+1i*w)*(-1-t))-1i*pi));
digits(64);
I=(1/2)*(exp((1+1i*w)*t)*(ei((1+1i*w)*(1-t))-ei((1+1i*w)*(-1-t))-1i*pi)...
    -exp((-1+1i*w)*t)*(ei((-1+1i*w)*(1-t))-ei((-1+1i*w)*(-1-t))-1i*pi));

%==========================================================================

%======================一、内置函数Gauss_Kronrod法则========================
% [I_gk,Er_gk]=quadgk(fun,-1,1,'AbsTol',1e-16,'RelTol',1e-8);
%==========================================================================


%====================== 二、内置函数Gauss_Kronrod法则=======================
% I_integral=integral(fun,-1,1,'AbsTol',1e-16,'RelTol',1e-8);
%==========================================================================


%==================三、Gauss_Leguerre求积:毕设课题==========================
digits(64);
laguerre=Laguerre(n);
xk=roots(laguerre);
ak=Ak(n);                       %求Laguerre系数
wk=vpa(ak./sum(ak));                 %求积权重
Q=0;
for a=1:n
    Q=Q+(1i*exp(-1*1i*w)/w)*wk(a)*sinh(-1+1i*xk(a)/w)/(-1-t+1i*xk(a)/w)...
    -(1i*exp(1i*w)/w)*wk(a)*sinh(1+1i*xk(a)/w)/(1-t+1i*xk(a)/w);
end

Q=Q+1i*exp(1i*w*t)*pi*sinh(t);

%==========================================================================



%内置函数积分值
%Er=abs(I_gk); 

%内置函数积分误差
% Er=Er_gk;
% Er=abs(imag(I_integral)-I);
if tag==1           %判断实虚部
    Er=abs(real(Q-I));
else
    Er=abs(imag(Q-I));
end

end

